////////////////////////////////////////////////////////////////////
            OUTLINE OF SERVICES AND OTHER COMPONENTS
////////////////////////////////////////////////////////////////////

///////////////////////////////
    RECIPECATALOGUE
///////////////////////////////

Main microservice providing an HTTP API for fetching, creating, updating and deleting
recipes and likes. 

Publishes events on recipe creation/deletion, as well as on likes creation/deletion.

///////////////////////////////
    RANKINGSERVICE
///////////////////////////////

Microservice tasked with keeping a ranking of recently created recipes and their likes. The ranking is
stored in an independent database and accessible via HTTP API.

It consumes recipe creation/deletion events, and keeps track of likes count by consuming likes 
creation/deletion events.



///////////////////////////////
    EVENT BUS
///////////////////////////////

Inteface in EventBusInterface.

Implementation using RabbitMQ in EventBusImplementation.

Offers methods to publish events and subscribe to them.




////////////////////////////////////////////////////////////////////
            RUNNING INDIVIDUAL SERVICES IN DOCKER
////////////////////////////////////////////////////////////////////

To build an individual service's image, e.g. RecipeCatalogue's image, in directory ./MyMicroserviceApp run:
 
    docker build -t recipecatalogue -f RecipeCatalogue/Dockerfile .

This uses the Dockerfile inside RecipeCatalogue folder to build an image for the
recipecatalogue microservice. Note that by calling the command in ./MyMicroserviceApp, the
docker build command can see the libraries for the RabbitMQ bus, which are referenced in
the Dockerfile and included in the container! I.e. the container will include a copy of these
libraries, as well as a copy of the RecipeCatalogue folder.

To run the image in a Docker container, run:

    docker run -p 8080:80 -d --name recipes recipecatalogue

This creates a container called "recipes" whose api can be accessed on port 8080.

To implement connections between services running on Docker, first create a virtual network with:

    docker network create MyMicroserviceAppNetwork

Then to run a container on the network, use the following variation of the above run command:

    docker run -p 8080:80 --network MyMicroserviceAppNetwork -d --name recipes recipecatalogue


To follow the logs of a given container from your console, use:
    docker logs -f [container_name]




////////////////////////////////////////////////////////////////////
            RUNNING THE ENTIRE APP (DOCKER COMPOSE)
////////////////////////////////////////////////////////////////////


TBD





////////////////////////////////////////////////////////////////////
                        UNIT TESTING
////////////////////////////////////////////////////////////////////

In directory Tests, find sub-directories for testing various components of the app.

In the appropriate sub-directory, run:
    
    dotnet test

### EventBusTest
This is a unit test for the libraries implementing the event bus on top of RabbitMQ.
The test requires RabbitMQ to be running in Docker as described below.

### EventListener
This is a console app (NOT AN ACTUAL TEST) used as a rudimentary integration test for the event bus.
The app uses the EventBus class library to listen to a given event type, and print
out a message when the event is received. A convenient way to see which events are being sent.

### IntegrationTestCatalogueRanking
Integaration test for the microservices RecipeCatalogue and RankingService. 
- The test launches in-memory instances of the two microservices.
- Then it sends RecipeCatalogue various http requests that generate events. 
- RankingService should subscribe to these events and updates its own database 
  once it receives them. The test checks that this is the case.




////////////////////////////////////////////////////////////////////
                            MONGODB
////////////////////////////////////////////////////////////////////

The MongoDB database runs locally for the moment.

Start the database server by running:
    mongod -dbpath ./MongoStore
in C:\







////////////////////////////////////////////////////////////////////
                             RABBITMQ
////////////////////////////////////////////////////////////////////

The RabbitMQ service runs as a container.

Start the RabbitMQ container by running:
    docker run -it --rm -d --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:4-management

OSS: To run RabbitMQ on the Docker virtual network for the application, use:

     docker run -it --rm --network MyMicroserviceAppNetwork -d --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:4-management

This makes it so that RabbitMQ can be accessed with HostName = "rabbimq" (i.e. the name of the RabbiMQ service in Docker!)

To look at the status of RabbitMQ, including queues, exchanges and messages, go to:
    http://localhost:15672
and login with username: guest, password: guest

